#' Run training set simulation
#' @keywords internal
#' @author Ghislain Durif
#' @details
#'  -h, --header arg        Header file (default: headerRF.txt)
#'  -r, --reftable arg      Reftable file (default: reftableRF.bin)
#'  -b, --statobs arg       Statobs file (default: statobsRF.txt)
#'  -o, --output arg        Prefix output (modelchoice_out or estimparam_out by
#'                                         default)
#'  -n, --nref arg          Number of samples, 0 means all (default: 0)
#'  -m, --minnodesize arg   Minimal node size. 0 means 1 for classification or
#'  5 for regression (default: 0)
#'  -t, --ntree arg         Number of trees (default: 500)
#'  -j, --threads arg       Number of threads, 0 means all (default: 0)
#'  -s, --seed arg          Seed, generated by default (default: 0)
#'  -c, --noisecolumns arg  Number of noise columns (default: 5)
#'  --nolinear          Disable LDA for model choice or PLS for parameter
#'  estimation
#'  --plsmaxvar arg     Percentage of maximum explained Y-variance for
#'  retaining pls axis (default: 0.9)
#'  --chosenscen arg    Chosen scenario (mandatory for parameter
#'                                       estimation)
#'  --noob arg          number of oob testing samples (mandatory for
#'                                                     parameter estimation)
#'  --parameter arg     name of the parameter of interest (mandatory for
#'                                                         parameter estimation)
#'  -g, --groups arg        Groups of models
abcranger_run <- function(proj_dir, run_mode, n_rec, 
                          min_node_size, n_tree, noise_columns, no_linear, 
                          pls_max_var, chosen_scenario, noob, parameter, 
                          groups = NULL) {
    # # debugging
    # print("abcranger args")
    # print(match.call())
    
    # executable
    abcranger_bin <- find_bin("abcranger")
    
    # check project dir
    if(!dir.exists(proj_dir)) {
        stop("Input directory does not exist")
    }
    
    # check for required files
    required_files <- c("headerRF.txt", "statobsRF.txt", "reftableRF.bin")
    if(!all(required_files %in% list.files(proj_dir))) {
        stop("missing required input file(s)")
    }
    
    ### run
    log_debug("abcranger run")
    arguments <- c(
        "-n", as.character(n_rec),
        "-m", as.character(min_node_size),
        "-t", as.character(n_tree),
        "-j", as.character(getOption("diyabcGUI")$ncore),
        "-c", as.character(noise_columns)
    )
    if(no_linear) {
        arguments <- c(arguments, "--no_linear")
    }
    if(run_mode == "param_estim") {
        arguments <- c(
            arguments,
            "--chosenscen", as.character(chosen_scenario),
            "--noob", as.character(noob),
            "--parameter", as.character(parameter)
        )
        if(!no_linear) {
            arguments <- c(arguments, "--plsmaxvar", as.character(pls_max_var))
        }
    } else if(
        (run_mode == "model_choice") &&
        !is.null(groups) && is.character(groups) && (str_length(groups) > 0)
    ) {
        arguments <- c(arguments, "-g", groups)
    }
    
    log_info(
        "cmd: ", 
        str_c(abcranger_bin, str_c(arguments, collapse = " "), sep = " ")
    )
    run_proc <- processx::process$new(
        command = abcranger_bin, 
        args = arguments,
        stdin = NULL,
        stdout = file.path(proj_dir, "abcranger_call.log"), 
        stderr = file.path(proj_dir, "abcranger_call.log"),
        echo_cmd = TRUE,
        wd = proj_dir
    )
    
    ## output process
    return(run_proc)
}

#' Clean up after abcranger
#' @keywords internal
#' @author Ghislain Durif
cleanup_abcranger_run <- function(project_dir) {
    # ## file list
    # files <- file.path(
    #     project_dir,
    #     c("abcranger_param_estim_call.log", 
    #       "abcranger_mod_choice_call.log")
    # )
    # # remove files
    # lapply(files, function(filename) {
    #     if(file.exists(filename)) {
    #         fs::file_delete(filename)
    #     }
    # })
}


#' Parse abcranger group arg
#' @keywords internal
#' @author Ghislain Durif
#' @description
#' For example, with six models, labeled from 1 to 6,",
#' `'1,2,3;4,5,6'` to make 2 groups of 3.
parse_abcranger_group <- function(txt, n_scenario) {
    # init output
    out <- list(valid = TRUE, msg = list())
    
    # check input
    if(is.null(txt) || (is.character(txt) && str_length(txt) == 0))
        return(out) # empty grouping/selection is ok
    
    if(!is.character(txt) || length(txt) > 1) {
        out$valid <- FALSE
        out$msg <- append(out$msg, list(tagList("Bad input")))
        return(out)
    }
    
    # # strip "|' (WHY??? -> to investigate)
    # tmp <- str_replace_all(txt, pattern = "\"|'", replacement = "")
    
    # check format
    pttrn <- "^([0-9]+(,[0-9]+)*)(;([0-9]+(,[0-9]+)*))*$"
    if(!str_detect(txt, pttrn)) {
        out$valid <- FALSE
        out$msg <- append(
            out$msg,
            list(tagList(
                "Issue with group formating. Use only",
                "numbers, commas (,) and semi-colons (;).", 
                "Example: '1,2;3' (if you have 3 or more scenarii)."
            ))
        )
        return(out)
    }
    
    # at least 2 groups
    if(!str_detect(txt, ";")) {
        out$valid <- FALSE
        out$msg <- append(
            out$msg,
            list(tagList(
                "You should specify at least two groups,",
                "separated by semi-colons", tags$code(";"), ".",
                "If you do not want to group scenarii",
                "(or equivalently assign each scenario",
                "to its own group), leave blank."
            ))
        )
    }
    
    # extract information
    pttrn <- "[0-9]+"
    scenario_list <- as.numeric(
        str_extract_all(txt, pttrn, simplify = TRUE)
    )
    
    # duplicated id ?
    if(length(scenario_list) != length(unique(scenario_list))) {
        count_scenarii <- table(scenario_list)
        duplicated_scenarii <- names(count_scenarii[count_scenarii>1])
        out$valid <- FALSE
        out$msg <- append(
            out$msg,
            list(tagList(
                "The following scenario", 
                ifelse(
                    length(duplicated_scenarii) > 1, 
                    "ids are", "id is"
                ),
                "duplicated:",
                str_c(
                    duplicated_scenarii,
                    collapse = ", "
                )
            ))
        )
        return(out)
    }
    
    # bad scenario id ?
    if(!all(scenario_list %in% (1:n_scenario))) {
        nonexisting_scenarii <- 
            scenario_list[!scenario_list %in% (1:n_scenario)]
        out$valid <- FALSE
        out$msg <- append(
            out$msg,
            list(tagList(
                "The following scenario", 
                ifelse(
                    length(nonexisting_scenarii) > 1, 
                    "ids do not", "id does not"
                ),
                "exist:",
                str_c(
                    nonexisting_scenarii,
                    collapse = ", "
                )
            ))
        )
        return(out)
    }
    
    # output
    return(out)
}


#' Abcranger postprocessing
#' @keywords internal
#' @author Ghislain Durif
#' @description
#' After a successfool abcranger run, result postprocessing includes graphical 
#' output generation.
abcranger_postprocess <- function(
    proj_dir, graph_dir, run_mode = "param_estim", 
    prefix = "estimparam_out", sub_proj_name = NULL, 
    param = NULL
) {
    # graphical output
    if(run_mode == "param_estim") {
        # parameter estimation
        if(!is.null(param)) {
            param_estim_graph_ouptut(proj_dir, proj_dir, param, prefix)
        }
        # move file to subproject directory
        abcranger_subdir(proj_dir, sub_proj_name, prefix)
    } else if(run_mode == "model_choice") {
        # model choice
        model_choice_graph_ouptut(proj_dir, proj_dir, prefix)
        # move file to subproject directory
        abcranger_subdir(proj_dir, sub_proj_name, prefix)
    }
}

#' Abcranger sub-project directory management
#' @keywords internal
#' @author Ghislain Durif
#' @description
#' After a successfool abcranger run, result files are moved to a dedicated 
#' sub-directory
abcranger_subdir <- function(proj_dir, sub_proj_name, prefix) {
    if(!is.null(sub_proj_name) && str_length(sub_proj_name) > 0) {
        # create sub-directory
        sub_dir_path <- file.path(proj_dir, sub_proj_name)
        if(!dir.exists(sub_dir_path)) {
            fs::dir_create(sub_dir_path)
        }
        # move output files
        tmp_file_list <- list.files(proj_dir, pattern = prefix)
        if(length(tmp_file_list) > 0) {
            tmp_file_info <- file.info(file.path(proj_dir, tmp_file_list))
            if(any(!tmp_file_info$isdir)) {
                tmp_file_list <- tmp_file_list[!tmp_file_info$isdir]
                tmp_move <- lapply(
                    tmp_file_list, 
                    function(tmp_file) {
                        fs::file_copy(
                            path = file.path(proj_dir, tmp_file),
                            new_path = file.path(sub_dir_path, tmp_file),
                            overwrite = TRUE
                        )
                        fs::file_delete(file.path(proj_dir, tmp_file))
                    }
                )
            }
        }
    }
}
